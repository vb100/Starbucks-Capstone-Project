'''
This file is supplementary to Udacity Capstone Project: Starbuck Case
Prepared by Vytautas Bielinskas (2021)
'''

# Import modules and packages
import pandas as pd
import numpy as np
from scipy.interpolate import interp1d
from matplotlib import pyplot as plt
import matplotlib.gridspec as gridspec
import seabornfig2grid as sfg
import seaborn as sns


# Get main information about the given dataset
def dataset_info(df, df_name):
	'''
	Args:
		df - a given dataset : <Pandas DataFrame>
	'''
	SEPARATOR = '- ' * 30
	print(f'{df_name} data shape = {df.shape}')
	print(f'Data Types:\n{df.dtypes}\n{SEPARATOR}')
	print(f'Dataframe Information:\n {df.describe()}\n{SEPARATOR}')
	print(f'Main Information:\n{df.info()}\n')

	return None


# Calculate ECDF for a given series of values
def ecdf(values):
	'''
	Args:
		values - a given values from a dataframe : <Pandas DataFrame -> Series of Values>
	'''
	# Number of data points: n
	n = len(values)
	# x-data for the ECDF: x
	x = np.sort(values)
	# y-data for the ECDF: y
	y = np.arange(1, len(x)+1) / n

	return x, y


# Plot ECDF graph for a given dataset and series of data in such dataset
def plot_ecdf(x, y, dataset_name, feature_name):
	'''
	Args:
		x, y - list of values generated by ecdf procedure : <list>, <list>
		dataset_name - a given name of actual dataset : <string>
		feature_name - a given name of actual feature in a dataset : <string>
	'''
	plt.rcParams['figure.figsize'] = (11.25, 3.15)
	_ = plt.title(f'Checking distribution for {dataset_name}: {feature_name}', family='IBM Plex Arabic', fontsize=13)
	_ = plt.xlabel('Actual Values', family='IBM Plex Arabic', fontsize=10)
	_ = plt.ylabel('ECDF percentage', family='IBM Plex Arabic', fontsize=10)
	_ = plt.plot(x, y, c='#677478', marker='o', markersize=2, linewidth=0, linestyle=None, label=f'{feature_name} Record')
	_ = plt.fill_between(x=x, y1=y, y2=0.5, color='green', where=y>=0.5, interpolate=True, alpha=0.12, label='Above Average')
	_ = plt.fill_between(x=x, y1=y, y2=0.5, color='red', where=y<0.5, interpolate=True, alpha=0.12, label='Below Average')
	_ = plt.axvspan(np.mean(x)-(np.nanstd(x)/2), np.mean(x)+(np.nanstd(x)/2), alpha=0.1, color='orange', label='Standard Deviation')
	_ = plt.axvline(x=np.median(x), color='magenta', linestyle='--', linewidth=1, label='Median value')
	_ = plt.yticks(np.linspace(0, 1, 11), family='IBM Plex Arabic', fontsize=9)
	_ = plt.grid(which='major', color='#cccccc', alpha=0.5)

	# Make some interpolations to draw lines between acutal point and median value
	inter = interp1d(x, y)
	y_median = inter(np.median(x))

	# Draw lines
	for this_x, this_y, in zip(x, y):
		_ = plt.plot([this_x, np.median(x)], [this_y, y_median], '--', color='#cccccc', alpha=0.05, linewidth=1)

	_ = plt.legend(shadow=True)
	plt.show()

	print(f'Average of {feature_name} = {np.round(np.mean(x), 2)}')
	print(f'Median of {feature_name} = {np.round(np.median(x), 2)}')
	print(f'Standard Deviation of {feature_name} = {np.round(np.std(x), 2)}')
	print(f'Minimum value of {feature_name} = {np.min(x)}, Maximum value of {feature_name} = {np.max(x)}')

	return None


# Plot Seaborn JointGrids in subplots on layyout 1x3
def plot_subplots_sns_1x3(data, feature, by_x, by_y):
	'''
	Args:
		data - a given DataFrame with data to be plotted : <pd.DataFrame>
		feature - a given feature that is used to separate distributions in data : <string>
		by_x, by_y - features which distributions should be ploted : <string>, <string>
	'''
	g_list = []
	if len(data[feature].unique()) == 3:
		unique_features = list(data[feature].unique())
		for this_feature in unique_features:
			this_subplot = sns.JointGrid(data=data[data[feature]==this_feature], x=by_x, y=by_y, space=0)
			this_subplot.ax_joint.text(
				int(np.median(data[data[feature]==this_feature][by_x]))+2,
				int(np.median(data[data[feature]==this_feature][by_y]))-6000,
				f'{by_x}={int(np.median(data[data[feature]==this_feature][by_x]))}', c='black', fontsize=9
				)
			this_subplot.ax_joint.text(
				int(np.median(data[data[feature]==this_feature][by_x]))+2,
				int(np.median(data[data[feature]==this_feature][by_y]))+4000,
				f'{by_y}={int(np.median(data[data[feature]==this_feature][by_y]))}', c='black', fontsize=9
				)
			this_subplot.fig.subplots_adjust(top=20.2)
			plt.title(this_feature, fontsize=11, family='IBM Plex Arabic')
			this_subplot.ax_joint.axvline(x=int(np.median(data[data[feature]==this_feature][by_x])), color='#070575', linestyle='--', linewidth=1)
			this_subplot.ax_joint.axhline(y=int(np.median(data[data[feature]==this_feature][by_y])), color='#070575', linestyle='--', linewidth=1)
			this_subplot.plot_joint(sns.kdeplot, fill=True, cmap='PuBuGn')
			this_subplot.plot_marginals(sns.histplot, kde = True, color="#cccccc", alpha=1, bins=25)

			g_list.append(this_subplot)

		fig = plt.figure(figsize=(11.25, 4.75))
		gs = gridspec.GridSpec(1, 3)

		for i, this_subplot in enumerate(g_list):
			sfg.SeabornFig2Grid(this_subplot, fig, gs[i])

		gs.tight_layout(fig)
		gs.update(top=0.7)

		plt.show()

	else:
		print(len(data[feature].unique()))

	return None


# Plot Density distributions with KDE (with Seaborn and Matplotlib)
def plot_kde_distributions(feature, by, data):
	'''
	Args:
		feature - name of feature that we want to see a distribution for : <string>
		by - a criterion of spliting distributions : <string>
		data - a given dataset : <Pandas DataFrame>
	'''

	colors = ['green', 'red', '#3495eb']

	plt.rcParams['figure.figsize'] = (11.25, 3.15)
	if len(data[by].unique()) > 0:
		for this_by, this_color in zip(list(data[by].unique()), colors):
			_ = sns.distplot(data[data[by]==this_by][feature], color = this_color, label = this_by)
			print(f'{by.capitalize()} = {this_by}: median {feature} = {np.median(data[data[by]==this_by][feature])}, size of distribution is {len(data[data[by]==this_by][feature])} records.')
	_ = plt.title(f'Distributions of Features by {feature.capitalize()}', fontsize=13, family='IBM Plex Arabic')
	_ = plt.xlabel(feature.capitalize(), fontsize=10, family='IBM Plex Arabic')
	_ = plt.ylabel('Density Count', fontsize=10, family='IBM Plex Arabic')
	_ = plt.grid(which='major', c='#cccccc', alpha=0.5)
	_ = plt.legend(shadow=True)
	plt.show()

	return None